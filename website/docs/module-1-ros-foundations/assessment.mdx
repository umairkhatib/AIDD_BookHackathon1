---
sidebar_position: 7
title: "ROS 2 Fundamentals Assessment"
---

# ROS 2 Fundamentals Assessment

## Overview

This assessment evaluates your understanding of ROS 2 fundamentals. Complete all sections to demonstrate your knowledge of ROS 2 architecture, communication patterns, and basic node implementation.

## Section 1: Conceptual Questions

### Question 1: ROS 2 Architecture
Explain the difference between a ROS 2 node, topic, and service. Provide examples of when you would use each.

**Expected Answer:**
- A **node** is an executable process that works as part of a ROS 2 system, implementing a portion of the robot's functionality.
- A **topic** is a named bus over which nodes exchange messages using a publish-subscribe pattern, suitable for continuous data streams.
- A **service** provides a request-response communication pattern, suitable for synchronous operations.

### Question 2: Communication Patterns
Describe the publish-subscribe communication pattern in ROS 2. What are the advantages and disadvantages compared to the service pattern?

**Expected Answer:**
- Publish-subscribe is asynchronous, allowing many-to-many communication
- Advantages: Decoupling, scalability, real-time data streaming
- Disadvantages: No guaranteed delivery, no response confirmation
- Services provide synchronous, request-response communication with guaranteed response

### Question 3: Quality of Service (QoS)
What is Quality of Service in ROS 2, and why is it important for robotics applications?

**Expected Answer:**
- QoS allows tuning communication behavior (reliability, durability, history, etc.)
- Important for robotics because different data types have different requirements
- Critical for real-time and safety-critical applications

## Section 2: Practical Implementation

### Exercise 1: Create a Publisher Node
Create a ROS 2 publisher node that publishes the current time in seconds to a topic called `current_time`. The node should publish a message every 2 seconds.

**Requirements:**
- Node name: `time_publisher`
- Topic name: `current_time`
- Message type: `std_msgs/Float64`
- Publish rate: Every 2 seconds

<details>
<summary>Sample Solution</summary>

```python
#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from std_msgs.msg import Float64
import time


class TimePublisher(Node):

    def __init__(self):
        super().__init__('time_publisher')
        self.publisher_ = self.create_publisher(Float64, 'current_time', 10)
        timer_period = 2.0  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)

    def timer_callback(self):
        msg = Float64()
        msg.data = time.time()
        self.publisher_.publish(msg)
        self.get_logger().info(f'Publishing current time: {msg.data}')


def main(args=None):
    rclpy.init(args=args)

    time_publisher = TimePublisher()

    rclpy.spin(time_publisher)

    # Destroy the node explicitly
    time_publisher.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
```

</details>

### Exercise 2: Create a Subscriber Node
Create a ROS 2 subscriber node that listens to the `current_time` topic and calculates the time difference between consecutive messages.

**Requirements:**
- Node name: `time_subscriber`
- Subscribe to: `current_time`
- Calculate and log the time difference between messages
- Handle the first message appropriately

<details>
<summary>Sample Solution</summary>

```python
#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from std_msgs.msg import Float64


class TimeSubscriber(Node):

    def __init__(self):
        super().__init__('time_subscriber')
        self.subscription = self.create_subscription(
            Float64,
            'current_time',
            self.listener_callback,
            10)
        self.subscription  # prevent unused variable warning
        self.previous_time = None

    def listener_callback(self, msg):
        current_time = msg.data

        if self.previous_time is not None:
            time_diff = current_time - self.previous_time
            self.get_logger().info(f'Time difference: {time_diff:.3f} seconds')
        else:
            self.get_logger().info('First time message received')

        self.previous_time = current_time


def main(args=None):
    rclpy.init(args=args)

    time_subscriber = TimeSubscriber()

    rclpy.spin(time_subscriber)

    # Destroy the node explicitly
    time_subscriber.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
```

</details>

### Exercise 3: Parameter-Based Node
Create a ROS 2 node that uses parameters to configure its behavior:
- Topic name to publish to (default: 'custom_topic')
- Message content (default: 'Default Message')
- Publish frequency (default: 1.0 Hz)

<details>
<summary>Sample Solution</summary>

```python
#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from std_msgs.msg import String


class ParameterPublisher(Node):

    def __init__(self):
        super().__init__('parameter_publisher')

        # Declare parameters with default values
        self.declare_parameter('topic_name', 'custom_topic')
        self.declare_parameter('message', 'Default Message')
        self.declare_parameter('frequency', 1.0)

        # Get parameter values
        self.topic_name = self.get_parameter('topic_name').value
        self.message = self.get_parameter('message').value
        self.frequency = self.get_parameter('frequency').value

        self.publisher_ = self.create_publisher(String, self.topic_name, 10)
        timer_period = 1.0 / self.frequency  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)
        self.i = 0

    def timer_callback(self):
        msg = String()
        msg.data = f'{self.message}: {self.i}'
        self.publisher_.publish(msg)
        self.get_logger().info(f'Publishing: "{msg.data}" to {self.topic_name}')
        self.i += 1


def main(args=None):
    rclpy.init(args=args)

    parameter_publisher = ParameterPublisher()

    rclpy.spin(parameter_publisher)

    # Destroy the node explicitly
    parameter_publisher.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
```

</details>

## Section 3: Analysis and Debugging

### Scenario 1: Communication Issues
You have a publisher node and a subscriber node, but the subscriber is not receiving any messages. List at least 3 possible causes and how to diagnose each.

**Expected Answers:**
1. **Different ROS_DOMAIN_ID**: Check with `echo $ROS_DOMAIN_ID` in both terminals
2. **Different QoS profiles**: Verify compatibility between publisher and subscriber QoS
3. **Network configuration**: Ensure nodes can communicate over DDS
4. **Node not properly initialized**: Check that rclpy.init() and node creation are successful

### Scenario 2: Performance Issues
Your ROS 2 system is experiencing high latency in message delivery. What factors could contribute to this, and how would you address them?

**Expected Answers:**
- Network bandwidth limitations
- QoS configuration (reliable vs best effort)
- Message size and frequency
- System resources (CPU, memory)
- DDS implementation and configuration

## Section 4: Advanced Concepts

### Exercise 4: Service Implementation
Implement a service that takes two integers as input and returns their sum and product.

**Requirements:**
- Service name: `math_operation`
- Service type: Create a custom service with request (a, b) and response (sum, product)
- Include both server and client implementations

<details>
<summary>Custom Service Definition (.srv file)</summary>

```
# Request
int64 a
int64 b
---
# Response
int64 sum
int64 product
```

</details>

## Evaluation Criteria

Your assessment will be evaluated based on:

1. **Conceptual Understanding (25%)**: Accuracy and depth of conceptual explanations
2. **Implementation Quality (40%)**: Correctness, efficiency, and best practices in code
3. **Problem Solving (25%)**: Ability to analyze and solve practical ROS 2 issues
4. **Documentation (10%)**: Code comments, logging, and clear variable names

## Submission Instructions

1. Implement all required exercises
2. Test your nodes to ensure they function correctly
3. Document your code with appropriate comments
4. Include logging statements to demonstrate understanding
5. Create a README.md file explaining your implementation approach

## Resources for Review

- [ROS 2 Documentation](https://docs.ros.org/en/humble/)
- [rclpy API Documentation](https://docs.ros.org/en/humble/p/rclpy/)
- Course materials on ROS 2 architecture and communication patterns

## Next Steps

Upon successful completion of this assessment, you will be ready to advance to more complex topics including:
- Advanced ROS 2 concepts
- Integration with simulation environments
- Robot modeling with URDF
- Advanced control techniques